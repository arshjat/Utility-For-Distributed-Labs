Check if n umbers to immediate left and right of decimal makes  a perfect square or not. Arsh Panghal [  IIT2017048   ] Anurag Gupta [ IIT2017049 ] Akshit Bansal [ IIT2017050   ] Prateek Nayak [ IIT2017051   ] Problem Statement Given a floating point number check whether its least significant integer part and most significant floating part together makes a perfect square or not.  Examples: 	234 3 . 4 34  => 34 => Not a perfect Square 	243 3 . 6 878 => 36 => Perfect Square   General Idea  The first approach towards solving this problem is to  construct a two-digit number  after finding the position of the decimal. After the number is formed,  loop in the stored numbers   and check whether  it is present . But since the use of the multiplication operator is not allowed, we have to design our own multiplication and division functions.  Design Of Multiply Function First approach is to loop from unity to smaller of the two numbers and add the larger number into the result.  Second approach is using shift operations discussed in next slide.  Multiplication u sing Binary shift  The foundation of computer science is based on the fact that any number can be represented as sums of powers of 2.   For example: 	10 = 2 3 +2 1 			15 = 2 3 +2 2 +2 1 +2 0 .    Using this fact we can multiply two numbers efficiently using shift operator.  Now if we represent the number ( n ) in binary notation left shifting the number   x  times  i.e.   n<<x   is equivalent to multiplying the number by  2 x .  Example:	  (25) 10  = (1101) 2  Shifting 25 by 1 unit towards left gives (11010) 2  which is equivalent to (50) 2 Combining above two facts :  	10*10 =  10 * (2 3  + 2 1 ) = (10  <<  3)  +  (10  <<  1) = 100 	20*10    =  20 * (2 3 +2 1 ) = (20  <<  3)  +  (20  <<  1) = 200  Brute Force algorithm After finding the decimal digit in the number multiply its least significant integer digit by 10 and add most significant fractional digit.  Loop the squares and check for equality.  Time Complexity   :   O (  k  ) k : number of digits in integer part of  ‘n’ Better Approaches Now after analysing the question we can infer that the number formed after concatenation will always be a single digit or two digit number.   Since number of 2 digit square numbers are only 10 we can reduce the computations by pre-storing the numbers in a lookup and checking.  Time Complexity  :  O (  1   )  Better Approaches As the unit digit of a perfect  square number depends only on the unit digit of its square root and unit digit can be any number from 0-9 so  unit digit of a perfect  square  can never end with digits 2, 3, 7 and 8.  So any number having these digits as most significant floating point cannot form a perfect square. Result Worst Time Complexity : O (k) [k: number of digits in  integral  part.] Best Time  Complexity : O(1) References IDAA432C Class Notes. Introduction to Algorithm, (CLRS) https://www.geeksforgeeks.org/stdstring-class-in-c/ https://www.geeksforgeeks.org/multiplication-two-numbers-shift-operator/ https://www.geeksforgeeks.org/string-find-in-cpp/ THANK YOU ! 